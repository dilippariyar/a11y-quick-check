<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A11y Quick Check</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Universal selector for dark theme, high contrast */
        * {
            color: #f3f4f6 !important; /* Set all text to light white/gray */
        }
        body {
            background-color: #1f2937; /* Dark background for the whole page */
            font-family: 'Inter', sans-serif;
            padding: 0 20px;
        }
        
        /* Structure */
        main {
            padding-top: 20px;
            padding-bottom: 40px;
            max-width: 4xl;
            margin-left: auto;
            margin-right: auto;
        }
        header, footer {
            max-width: 4xl;
            margin-left: auto;
            margin-right: auto;
            padding-left: 20px;
            padding-right: 20px;
        }
        header {
            padding-top: 20px;
            border-bottom: 4px solid #4f46e5;
        }
        footer {
            padding: 15px 0;
            margin-top: 20px;
            text-align: center;
            border-top: 1px solid #374151;
            color: #9ca3af !important;
        }

        /* Skip Link Accessibility CSS */
        .skip-link {
            position: absolute;
            top: -40px; /* Hidden off-screen by default */
            left: 0;
            background: #4f46e5;
            color: white !important;
            padding: 8px 16px;
            z-index: 1000;
            border-radius: 0 0 8px 8px;
            text-decoration: none;
            font-weight: bold;
            transition: top 0.3s ease-out;
        }
        .skip-link:focus {
            top: 0; /* Visible when focused */
            outline: 4px solid #fcd34d; /* High-contrast outline */
            outline-offset: -1px;
        }


        /* Specific overrides for contrast and usability */
        #codeInput {
            color: #111827 !important; /* Input text must be dark */
            background-color: white !important; /* Input background must be light */
            resize: vertical;
            min-height: 200px;
            border: 2px solid #6b7280;
            border-radius: 8px;
        }
        button {
            background-color: #4f46e5;
            color: white !important;
            transition: background-color 0.2s;
            border-radius: 8px;
        }
        button:hover {
            background-color: #4338ca;
        }
        h1, h2, h3 {
            color: #f3f4f6 !important;
            border-bottom: 2px solid #374151; /* Lighter border for dark background */
        }
        
        /* Status message colors adjusted for dark background */
        .ERROR { color: #f87171 !important; } /* Light Red */
        .WARNING { color: #fcd34d !important; } /* Light Yellow */
        .SUCCESS { color: #4ade80 !important; } /* Light Green */
        .INFO { color: #9ca3af !important; } /* Muted Light Gray */
        
        #results ul {
            list-style-type: none;
            padding-left: 1rem;
        }
        #results li {
            margin-bottom: 5px;
            padding-left: 1.5rem;
            position: relative;
        }
        #results li:before {
            content: '•';
            position: absolute;
            left: 0;
            color: #4f46e5; /* Keep the bullet color consistent */
            font-weight: bold;
        }
        /* Styling for the displayed code within the collapsible section */
        #formattedCodeDisplay {
            color: #60a5fa !important; /* Light blue code text */
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.4;
            white-space: pre-wrap; /* Allows long lines to wrap */
            word-wrap: break-word; /* Ensures long words are broken */
        }
        code {
            background-color: #374151; /* Darker background for code snippets */
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.875rem;
            color: #60a5fa !important; /* Light blue code text */
        }
    </style>
</head>
<body>

    <!-- Skip to Main Content Link (Keyboard-only users see this first on Tab) -->
    <a href="#main-content" class="skip-link">Skip to Main Content</a>

    <header>
        <h1 class="text-3xl font-extrabold mb-4">A11y Quick Check</h1>
        
        <!-- Instructions for the Bookmarklet -->
        <div class="mb-6 p-4 bg-gray-700 border-l-4 border-indigo-400 rounded-lg text-sm text-gray-50">
            <h2 class="text-xl font-bold mb-2 border-b-0 text-white !important">⚡️ Instant Audit Feature (Bookmarklet)</h2>
            <p class="mb-2">To audit a page instantly, save the JavaScript code below as a new bookmark in your browser's toolbar. When you are viewing a page you want to audit, simply click this bookmark. **It will open the results in a new tab.**</p>
            <p class="font-semibold mb-1 text-white">Bookmarklet Code (Drag-and-Drop or Copy):</p>
            <!-- NOTE: Updated the code to include the absolute URL based on the user's hosting location -->
            <textarea readonly id="bookmarkletCode" class="w-full p-2 text-xs text-gray-900 bg-gray-200 rounded-md select-all" rows="4">javascript:(function(){const code=encodeURIComponent(document.documentElement.outerHTML);const auditUrl='https://dilippariyar.github.io/a11y-quick-check/#code='+code;window.open(auditUrl, '_blank');})();</textarea>
            <p class="mt-2 text-xs text-gray-400">**Current URL used**: https://dilippariyar.github.io/a11y-quick-check/</p>
        </div>
        
        <!-- Old Instructions -->
        <div class="mb-6 p-4 bg-gray-700 border-l-4 border-indigo-400 rounded-lg text-sm text-gray-50">
            <p class="font-semibold mb-1 text-white">Manual Source Code Input:</p>
            <p>1. Open the web page you want to check, then press Control + U (Cmd + Option + U on Mac) to view its source code.</p>
            <p>2. Select all (Control + A / Cmd + A) and copy (Control + C / Cmd + C) the content, then paste it into the edit box below.</p>
        </div>
    </header>

    <main id="main-content">
        <!-- Updated to use <label> associated with the textarea -->
        <label for="codeInput" class="block mb-2 font-medium">
            Paste the HTML **Source Code** or wait for the Bookmarklet to auto-fill.
        </label>

        <textarea id="codeInput" rows="20" class="w-full p-4 text-sm focus:ring-indigo-500 focus:border-indigo-500 shadow-sm"></textarea>
        
        <!-- Audit Button -->
        <button onclick="checkAccessibility()" class="w-full py-3 px-6 text-lg font-semibold shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50">
            Run Accessibility Audit
        </button>
        
        <!-- Download Button - accesskey="r" added -->
        <button id="downloadBtn" onclick="downloadResults()" class="w-full py-3 px-6 text-lg font-semibold shadow-lg focus:outline-none mt-2 bg-green-600 hover:bg-green-700 hidden" accesskey="r">
            Download Audit Results (<span class="font-bold underline">Alt+R</span>)
        </button>

        <!-- ARIA Live Region for Screen Reader Announcements -->
        <div id="live-announcer" aria-live="polite" role="status" style="position: absolute; clip: rect(1px, 1px, 1px, 1px); padding: 0; border: 0; height: 1px; width: 1px; overflow: hidden;"></div>

        <!-- Audit Results Section -->
        <div id="results" class="mt-8 pt-4 border-t-2 border-gray-600">
            <!-- Accessibility results will be displayed here -->
            <p class="INFO text-lg font-medium">Results will appear here after the audit runs.</p>
        </div>
        
        <!-- Collapsible Source Code Section (Initially Hidden) -->
        <div id="codeSourceContainer" class="mt-8 pt-4 border-t-2 border-gray-600 hidden">
            <details id="sourceCodeDetails" class="rounded-lg shadow-xl overflow-hidden bg-gray-700">
                <summary class="cursor-pointer p-4 text-xl font-bold bg-indigo-600 hover:bg-indigo-700 rounded-lg focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50">
                    View Source Code (Cleaner Format)
                </summary>
                <div class="p-4">
                    <!-- Source code will be displayed here -->
                    <pre id="formattedCodeDisplay" class="p-3 bg-gray-800 rounded-lg text-xs overflow-auto"></pre>
                </div>
            </details>
        </div>
    </main>
    
    <footer>
        <!-- WCAG version updated to 2.2 -->
        <p>A11y Quick Check | Auditing WCAG 2.2 Principles.</p>
        <p class="mt-1 text-sm text-gray-400">This tool is built with screen readers in mind, utilizing ARIA landmarks, proper heading structure, and a dedicated live region for status updates.</p>
    </footer>

    <script>
        // --- AUTORUN LOGIC FOR BOOKMARKLET ---
        window.onload = function() {
            const hash = window.location.hash;
            const codeInput = document.getElementById('codeInput');
            const liveAnnouncer = document.getElementById('live-announcer');

            // Check if the URL contains the code payload from the bookmarklet
            if (hash.startsWith('#code=')) {
                try {
                    // Extract and decode the source code
                    const encodedCode = hash.substring(6);
                    const decodedCode = decodeURIComponent(encodedCode);
                    
                    if (decodedCode.trim().length > 0) {
                        codeInput.value = decodedCode;
                        
                        // Clear the hash from the URL to allow rerunning the bookmarklet later
                        history.replaceState(null, null, ' ');
                        
                        // Announce and automatically run the audit
                        liveAnnouncer.textContent = 'Source code loaded automatically. Running accessibility audit now.';
                        checkAccessibility();
                    }
                } catch (e) {
                    liveAnnouncer.textContent = 'Failed to load source code from URL hash due to an encoding error.';
                    console.error("Decoding error:", e);
                }
            }
        };


        // Utility function to safely display HTML code snippets
        function escapeHTML(str) {
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&#039;');
        }
        
        // Utility function to extract the complete opening tag of an element
        function getOpeningTag(element) {
            const outerHTML = element.outerHTML;
            const openingTagEnd = outerHTML.indexOf('>') + 1;
            return outerHTML.substring(0, openingTagEnd);
        }
        
        // Function to display the source code in the collapsible section
        function displayFormattedCode(code) {
            const container = document.getElementById('codeSourceContainer');
            const displayElement = document.getElementById('formattedCodeDisplay');

            if (container && displayElement) {
                // Escape the HTML for safe display inside <pre>
                displayElement.textContent = code;
                
                // Show the container after the first audit run
                container.classList.remove('hidden');
            }
        }

        // Function to handle downloading the results as a text file
        function downloadResults() {
            const resultsDiv = document.getElementById('results');
            const resultsHTML = resultsDiv.innerHTML;
            const liveAnnouncer = document.getElementById('live-announcer');

            // Check if results exist
            if (!resultsHTML.trim() || resultsHTML.includes('Results will appear here')) {
                console.warn('Attempted to download results before an audit was run.');
                liveAnnouncer.textContent = 'Download failed. Please run an audit first.';
                return;
            }

            // 1. Create a temporary element to strip complex HTML but preserve structure
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = resultsHTML;

            let outputText = "========================================================\n";
            outputText += "             A11y Quick Check Audit Report\n";
            outputText += "========================================================\n";
            outputText += "Date of Audit: " + new Date().toLocaleString() + "\n";
            outputText += "--------------------------------------------------------\n\n";

            // 2. Format the output text using DOM traversal
            Array.from(tempDiv.children).forEach(section => {
                const sectionText = section.textContent.trim();
                
                if (section.tagName === 'H2') {
                    // Main section heading
                    outputText += "\n\n========================================================\n";
                    outputText += sectionText.toUpperCase() + "\n";
                    outputText += "========================================================\n\n";
                } else if (section.tagName === 'H3') {
                    // Sub-heading 
                    outputText += "\n--- " + sectionText + " ---\n\n";
                } else if (section.tagName === 'P') {
                    // Paragraph text (like the success/error messages at the start of results)
                    outputText += sectionText + "\n\n";
                } else if (section.tagName === 'UL') {
                    // List items (the core audit findings)
                    Array.from(section.querySelectorAll('li')).forEach(li => {
                        // Replace multiple spaces and newlines with a single space, then prefix with *
                        const itemText = li.textContent.trim().replace(/\s\s+/g, ' ');
                        const severity = li.className.toUpperCase().replace(/ !IMPORTANT/g, '') || 'INFO';
                        outputText += `[${severity}] * ${itemText}\n`;
                    });
                    outputText += "\n";
                }
            });

            // 3. Create and trigger download
            const blob = new Blob([outputText], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            // Dynamic filename
            const filename = 'a11y_audit_report_' + new Date().toISOString().slice(0, 10) + '.txt';
            link.download = filename;
            
            // Trigger download silently
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // 4. ANNOUNCE SUCCESS FOR SCREEN READERS
            liveAnnouncer.textContent = `Audit results successfully downloaded as ${filename}.`;
        }

        // Main function to run all accessibility checks
        function checkAccessibility() {
            const htmlCode = document.getElementById('codeInput').value;
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = ''; // Clear previous results
            const downloadBtn = document.getElementById('downloadBtn');

            if (!htmlCode.trim()) {
                resultsDiv.innerHTML = '<p class="ERROR font-semibold">Please enter some HTML source code to run the audit.</p>';
                document.getElementById('live-announcer').textContent = 'Audit requires input code.';
                downloadBtn.classList.add('hidden'); // Hide on failure
                return;
            }

            let totalAuditIssues = 0;

            try {
                const parser = new DOMParser();
                // Use 'text/html' to parse the snippet as a full document
                const doc = parser.parseFromString(htmlCode, 'text/html');

                // Run each audit section and accumulate issues
                totalAuditIssues += checkDocumentBasics(doc, resultsDiv);
                totalAuditIssues += checkHeadingStructure(doc, resultsDiv);
                totalAuditIssues += checkAriaLandmarks(doc, resultsDiv);
                totalAuditIssues += checkImgRoleImgAccessibility(doc, resultsDiv);
                totalAuditIssues += checkGraphicsAndIconsAccessibility(doc, resultsDiv); 
                totalAuditIssues += checkButtonAccessibility(doc, resultsDiv);
                totalAuditIssues += checkLinkAccessibility(doc, resultsDiv);
                totalAuditIssues += checkTableAccessibility(doc, resultsDiv);
                totalAuditIssues += checkIframeAccessibility(doc, resultsDiv);
                totalAuditIssues += checkMediaAccessibility(doc, resultsDiv);
                totalAuditIssues += checkFormsAccessibility(doc, resultsDiv); 
                totalAuditIssues += checkKeyboardFocus(doc, resultsDiv);
                totalAuditIssues += checkFormIdUniqueness(doc, resultsDiv); 
                
                // Display the original code in the collapsible section (new feature)
                displayFormattedCode(htmlCode);


                if (totalAuditIssues === 0) {
                    resultsDiv.innerHTML = '<p class="SUCCESS font-semibold">No issues found based on the implemented checks. Great job!</p>' + resultsDiv.innerHTML;
                }
                
                // Show download button on successful audit
                downloadBtn.classList.remove('hidden');

            } catch (error) {
                resultsDiv.innerHTML = '<h2 class="ERROR">Parsing Error</h2><p>Could not parse the provided HTML source code: ' + escapeHTML(error.message) + '</p>';
                console.error("Parsing error:", error);
                downloadBtn.classList.add('hidden'); // Hide on parsing error
            }

            // ARIA Live Announcement when complete with total issues
            document.getElementById('live-announcer').textContent = `Accessibility audit complete. Found ${totalAuditIssues} potential issues.`;
        }
        
        // --- START OF AUDIT FUNCTIONS (Kept consistent with previous request) ---

        // 13. ID Uniqueness Check
        function checkFormIdUniqueness(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            const allElementsWithId = Array.from(doc.querySelectorAll('[id]'));
            const idMap = new Map();

            // 1. Map IDs to elements
            allElementsWithId.forEach(el => {
                const id = el.id.trim();
                if (id) {
                    if (!idMap.has(id)) {
                        idMap.set(id, []);
                    }
                    idMap.get(id).push(el);
                }
            });

            // 2. Identify and report duplicates
            const duplicateIds = Array.from(idMap.entries()).filter(([, elements]) => elements.length > 1);
            issueCount = duplicateIds.length;

            let html = `<h2>13. ID Uniqueness Check (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                listHtml += '<ul><li class="ERROR">ERROR: Found duplicate <code>id</code> attributes. The <code>id</code> **must be unique** in the document. Duplicate IDs cause labels (and ARIA relationships) to target the wrong element.</li>';
                
                duplicateIds.forEach(([id, elements]) => {
                    listHtml += '<ul><li>**Duplicate ID**: <code>' + escapeHTML(id) + '</code> (' + elements.length + ' occurrences):';
                    listHtml += '<ul>';
                    elements.forEach(el => {
                        const tag = el.tagName.toLowerCase();
                        const openingTag = getOpeningTag(el);
                        listHtml += `<li class="ERROR">Tag: <code>&lt;${tag}&gt;</code>. Source Code (Opening Tag): <code>${escapeHTML(openingTag)}</code></li>`;
                    });
                    listHtml += '</ul></li></ul>';
                });
                listHtml += '</ul>';
                html += listHtml;
            } else {
                 html += '<p class="SUCCESS text-sm">No duplicate <code>id</code> attributes found.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 1. Document Basics Check
        function checkDocumentBasics(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            // 1.1 Page Title (<title>)
            const pageTitle = doc.querySelector('title')?.textContent;
            if (!pageTitle || pageTitle.trim().length === 0) {
                listHtml += `<li class="WARNING">WARNING: Page Title (&lt;title&gt;) is missing or empty. This is crucial for context.</li>`;
                issueCount++;
            }

            // 1.2 Page Language (lang attribute on <html>)
            const htmlTag = doc.querySelector('html');
            const langAttr = htmlTag ? htmlTag.getAttribute('lang') : null;

            if (!langAttr || langAttr.trim().length < 2) {
                listHtml += '<li class="ERROR">ERROR: Page language (<code>lang</code> attribute on the <code>&lt;html&gt;</code> tag) is missing or invalid. This is required for screen readers (WCAG 3.1.1).</li>';
                issueCount++;
            }

            // 1.3 Skip to Main Content (Link)
            const skipLink = doc.querySelector('a[href*="#"][href*="main"], a[href*="#content"]');
            if (!skipLink) {
                listHtml += '<li class="WARNING">WARNING: "Skip to main content" link not found. Consider adding one for keyboard users.</li>';
                issueCount++;
            }
            
            let html = `<h2>1. Document Basics (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">Document Basics (Title, Lang, Skip Link) check passed.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 2. Heading Structure Check
        function checkHeadingStructure(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 
            
            const headings = Array.from(doc.querySelectorAll('h1, h2, h3, h4, h5, h6'));
            const headingLevels = headings.map(h => parseInt(h.tagName.substring(1)));

            // H1 availability and count
            const h1Count = headingLevels.filter(level => level === 1).length;
            if (h1Count === 0) {
                listHtml += '<li class="WARNING">WARNING: Primary heading (&lt;h1&gt;) is missing. Every page should have a single &lt;h1&gt;.</li>';
                issueCount++;
            } else if (h1Count > 1) {
                listHtml += `<li class="ERROR">ERROR: Multiple &lt;h1&gt; tags found (${h1Count}). A page should generally only contain one &lt;h1&gt;.</li>`;
                issueCount++;
                headings.filter(h => h.tagName === 'H1').forEach(h => {
                    listHtml += `<ul><li>Source Code: <code>${escapeHTML(h.outerHTML)}</code></li></ul>`;
                });
            }

            // Heading Level Skip
            for (let i = 0; i < headingLevels.length - 1; i++) {
                const currentLevel = headingLevels[i];
                const nextLevel = headingLevels[i+1];
                if (nextLevel > currentLevel + 1) {
                    listHtml += `<li class="ERROR">ERROR: Heading level skipped! Found &lt;h${currentLevel}&gt; followed by &lt;h${nextLevel}&gt;. You skipped level(s) up to &lt;h${currentLevel + 1}&gt;.`;
                    listHtml += `<ul><li>Source Code Snippet: &lt;h${currentLevel}&gt;... followed by &lt;h${nextLevel}&gt;...</li></ul></li>`;
                    issueCount++;
                }
            }

            let html = `<h2>2. Heading Structure (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">Heading structure and usage is correct.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 3. ARIA Landmark Check
        function checkAriaLandmarks(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';

            const landmarks = [
                { name: 'Header/Banner', selector: 'header, [role="banner"]', tag: '&lt;header&gt; or role="banner"' },
                { name: 'Main', selector: 'main, [role="main"]', tag: '&lt;main&gt; or role="main"' },
                { name: 'Footer/Contentinfo', selector: 'footer, [role="contentinfo"]', tag: '&lt;footer&gt; or role="contentinfo"' },
                { name: 'Navigation', selector: 'nav, [role="navigation"]', tag: '&lt;nav&gt; or role="navigation"' }
            ];

            landmarks.forEach(landmark => {
                const element = doc.querySelector(landmark.selector);
                if (!element) {
                    listHtml += `<li class="WARNING">WARNING: ${landmark.name} is missing. Use ${landmark.tag} to define this landmark.</li>`;
                    issueCount++;
                }
            });

            let html = `<h2>3. ARIA Landmarks (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">All required ARIA Landmarks (Header, Main, Footer, Nav) are present.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 4. Image Accessibility Check (Focus on <img> and role="img")
        function checkImgRoleImgAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            
            const imgRoleImgElements = Array.from(doc.querySelectorAll('img, [role="img"]'));
            const totalImgsFound = imgRoleImgElements.length;

            const imgs = Array.from(doc.querySelectorAll('img'));

            const imgsWithoutAlt = imgs.filter(img => !img.hasAttribute('alt'));
            const imgsWithEmptyAlt = imgs.filter(img => img.hasAttribute('alt') && img.getAttribute('alt').trim() === '');
            
            issueCount += imgsWithoutAlt.length + imgsWithEmptyAlt.length;

            let html = `<h2>4. Image Accessibility (${issueCount} issues)</h2>`;
            
            if (totalImgsFound > 0) {
                 html += `<p class="INFO text-sm">Total <code>&lt;img&gt;</code> or <code>role="img"</code> elements found: ${totalImgsFound}</p>`;
            }


            if (imgsWithoutAlt.length > 0) {
                listHtml += `<h3>&lt;img&gt; without 'alt' attribute (${imgsWithoutAlt.length} issues)</h3><ul>`;
                imgsWithoutAlt.forEach(img => {
                    listHtml += `<li class="ERROR">ERROR: Missing 'alt'. Source Code: <code>${escapeHTML(img.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }

            if (imgsWithEmptyAlt.length > 0) {
                listHtml += `<h3>&lt;img&gt; with empty 'alt' attribute (alt="") (${imgsWithEmptyAlt.length} issues)</h3><ul>`;
                imgsWithEmptyAlt.forEach(img => {
                    listHtml += `<li class="WARNING">WARNING: Empty 'alt' (<code>alt=""</code>) suggests the image is decorative. Use this deliberately. Source Code: <code>${escapeHTML(img.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }
            
            
            if (issueCount > 0) {
                html += listHtml;
            } else if (totalImgsFound > 0) {
                 html += '<p class="SUCCESS text-sm">All images found have appropriate <code>alt</code> text applied.</p>';
            } else {
                 html += '<p class="INFO text-sm">No <code>&lt;img&gt;</code> or <code>role="img"</code> elements found to check.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }
        
        // 5. Icons, SVG, and Canvas Accessibility Check
        function checkGraphicsAndIconsAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            const allElements = Array.from(doc.querySelectorAll('*')); 

            // --- 5.1 ICON CHECK (e.g., Font Awesome) ---
            const iconElements = allElements.filter(el => 
                (el.tagName === 'I' || el.tagName === 'SPAN') && el.className.includes('fa-')
            );

            const iconIssues = iconElements.filter(el => {
                const isHidden = el.getAttribute('aria-hidden') === 'true';
                const hasLabel = el.hasAttribute('aria-label') || el.hasAttribute('aria-labelledby');
                return !isHidden && !hasLabel;
            });
            
            issueCount += iconIssues.length;

            if (iconIssues.length > 0) {
                listHtml += `<h3>Icon Elements Missing Label or Hidden (${iconIssues.length} issues)</h3><ul>`;
                iconIssues.forEach(el => {
                    listHtml += `<li class="WARNING">WARNING: Icon found that is neither hidden (<code>aria-hidden="true"</code>) nor labeled (<code>aria-label</code> or <code>aria-labelledby</code>). Source Code: <code>${escapeHTML(el.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }


            // --- 5.2 SVG CHECK ---
            const svgElements = Array.from(doc.querySelectorAll('svg'));
            const svgIssues = svgElements.filter(svg => {
                const isHidden = svg.getAttribute('aria-hidden') === 'true';
                const hasAriaLabel = svg.hasAttribute('aria-label') || svg.hasAttribute('aria-labelledby');
                const hasTitle = svg.querySelector('title') !== null;
                
                return !isHidden && !hasAriaLabel && !hasTitle;
            });

            issueCount += svgIssues.length;

            if (svgIssues.length > 0) {
                listHtml += `<h3>SVG Accessibility (${svgIssues.length} issues)</h3><ul>`;
                svgIssues.forEach(svg => {
                    listHtml += `<li class="WARNING">WARNING: Non-decorative &lt;svg&gt; element is missing accessible name (&lt;title&gt;, <code>aria-label</code>, or <code>aria-labelledby</code>). Source Code (Opening Tag): <code>${escapeHTML(svg.outerHTML.substring(0, 50) + '...')}</code></li>`;
                });
                listHtml += '</ul>';
            }

            
            // --- 5.3 CANVAS CHECK ---
            const canvasElements = Array.from(doc.querySelectorAll('canvas'));
            const canvasIssues = canvasElements.filter(canvas => {
                const hasFallback = canvas.innerHTML.trim().length > 0;
                const hasAriaLabel = canvas.hasAttribute('aria-label') || canvas.hasAttribute('aria-labelledby');

                return !hasFallback && !hasAriaLabel;
            });

            issueCount += canvasIssues.length;

            if (canvasIssues.length > 0) {
                listHtml += `<h3>Canvas Accessibility (${canvasIssues.length} issues)</h3><ul>`;
                canvasIssues.forEach(canvas => {
                    listHtml += `<li class="ERROR">ERROR: &lt;canvas&gt; is missing visible fallback content and accessible name (<code>aria-label</code> or <code>aria-labelledby</code>). Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(canvas))}...</code></li>`;
                });
                listHtml += '</ul>';
            }

            
            let html = `<h2>5. Icons, SVG, and Canvas Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                html += '<p class="SUCCESS text-sm">Icons, SVGs, and Canvas elements are correctly hidden or labeled.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 6. Button Accessibility Check
        function checkButtonAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 
            
            // --- 6.1 Native <button> without accessible name ---
            const nativeButtons = Array.from(doc.querySelectorAll('button'));
            const noLabelNativeButtons = nativeButtons.filter(btn => {
                const hasVisibleText = btn.textContent.trim().length > 0;
                const hasAriaLabel = btn.hasAttribute('aria-label') || btn.hasAttribute('aria-labelledby');
                return !hasVisibleText && !hasAriaLabel;
            });
            
            issueCount += noLabelNativeButtons.length;

            if (noLabelNativeButtons.length > 0) {
                listHtml += `<h3>Native &lt;button&gt; without Accessible Name (${noLabelNativeButtons.length} issues)</h3><ul>`;
                noLabelNativeButtons.forEach(btn => {
                    listHtml += `<li class="ERROR">ERROR: &lt;button&gt; has no visible text and is missing <code>aria-label</code> or <code>aria-labelledby</code>. Source Code: <code>${escapeHTML(btn.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }


            // --- 6.2 Custom role="button" Check ---
            const customButtons = Array.from(doc.querySelectorAll('[role="button"]'));
            const noTabIndexButtons = customButtons.filter(btn => btn.getAttribute('tabindex') !== '0');

            issueCount += noTabIndexButtons.length; 

            if (noTabIndexButtons.length > 0) {
                listHtml += `<h3>Custom role="button" without tabindex="0" (${noTabIndexButtons.length} issues)</h3><ul>`;
                noTabIndexButtons.forEach(btn => {
                    listHtml += `<li class="ERROR">ERROR: Custom button element is missing <code>tabindex="0"</code>, making it unfocusable by keyboard. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(btn))}</code></li>`;
                });
                listHtml += '</ul>';
            }
            
            // Final H2 with total issue count
            let html = `<h2>6. Button Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                html += '<p class="SUCCESS text-sm">All button elements appear to be correctly labeled and keyboard accessible.</p>';
            }
            resultsDiv.innerHTML += html;

            return issueCount;
        }

        // 7. Link Accessibility Check
        function checkLinkAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            
            const genericTexts = [
                "learn more", "read more", "view more", "click here", "go", "link", 
                "details", "here", "more", "find out"
            ];

            const links = Array.from(doc.querySelectorAll('a'));
            
            const genericLinks = links.filter(link => {
                const text = link.textContent.trim().toLowerCase();
                
                if (link.getAttribute('aria-hidden') === 'true' || link.hasAttribute('aria-label') || link.hasAttribute('aria-labelledby')) {
                    return false;
                }

                const isGeneric = genericTexts.some(generic => {
                    if (text === generic) return true;
                    return text.startsWith(generic + ' ') || text.endsWith(' ' + generic) || text.includes(' ' + generic + ' ');
                });

                return isGeneric;
            });

            issueCount = genericLinks.length;

            if (genericLinks.length > 0) {
                listHtml += `<h3>Generic Link Text Found (${genericLinks.length} issues)</h3><ul>`;
                genericLinks.forEach(link => {
                    const linkText = link.textContent.trim();
                    listHtml += `<li class="ERROR">ERROR: Link text "<strong>${escapeHTML(linkText)}</strong>" is generic and lacks context when read out of context. Consider rewriting or adding <code>aria-label</code>. Source Code: <code>${escapeHTML(link.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }

            let html = `<h2>7. Link Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                html += '<p class="SUCCESS text-sm">No overly generic link text was found.</p>';
            }
            resultsDiv.innerHTML += html;

            return issueCount;
        }


        // 8. Table Accessibility Check
        function checkTableAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            const tables = Array.from(doc.querySelectorAll('table'));

            tables.forEach((table, index) => {
                const hasTh = table.querySelector('th');
                const hasColScope = table.querySelector('th[scope="col"]');
                const hasRowScope = table.querySelector('th[scope="row"]');
                
                if (!hasTh) {
                    listHtml += `<li class="ERROR">ERROR: Table ${index + 1} is missing semantic header tags (<code>&lt;th&gt;</code>). Headers are essential for navigation and context. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(table))}...</code></li>`;
                    issueCount++;
                } 
                else if (!hasColScope && !hasRowScope && hasTh) {
                    listHtml += `<li class="WARNING">WARNING: Table ${index + 1} uses <code>&lt;th&gt;</code> but lacks explicit <code>scope="col"</code> or <code>scope="row"</code> attributes. Consider adding scope for clear structure. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(table))}...</code></li>`;
                    issueCount++;
                }
            });

            let html = `<h2>8. Table Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">Table structure appears sound (or no tables were found).</p>';
            }
            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 9. Iframe Accessibility Check
        function checkIframeAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            const iframes = Array.from(doc.querySelectorAll('iframe'));

            iframes.forEach((iframe, index) => {
                const title = iframe.getAttribute('title');
                
                if (!title || title.trim() === '') {
                    listHtml += `<li class="ERROR">ERROR: Iframe ${index + 1} is missing a non-empty <code>title</code> attribute. This title is essential for screen reader users to understand the frame's content. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(iframe))}...</code></li>`;
                    issueCount++;
                }
            });

            let html = `<h2>9. Iframe Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">All iframes (or none) have a valid <code>title</code> attribute.</p>';
            }
            resultsDiv.innerHTML += html;
            return issueCount;
        }
        
        // 10. Media Accessibility Check
        function checkMediaAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            const mediaFound = doc.querySelectorAll('video, audio').length > 0;

            // --- 10.1 Video Captions/Subtitles Check ---
            const videos = Array.from(doc.querySelectorAll('video'));
            
            videos.forEach((video, index) => {
                const hasCaptions = video.querySelector('track[kind="captions"], track[kind="subtitles"]');
                
                if (!hasCaptions) {
                    listHtml += `<li class="ERROR">ERROR: Video ${index + 1} is missing a <code>&lt;track&gt;</code> element for captions or subtitles. This is essential for deaf users. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(video))}...</code></li>`;
                    issueCount++;
                }
            });
            if (videos.length > 0) {
                listHtml += `<h3>Video Captions/Subtitles (${videos.length} &lt;video&gt; elements checked)</h3><ul>` + listHtml + '</ul>';
            }


            // --- 10.2 Audio Controls/Transcript Check ---
            const audios = Array.from(doc.querySelectorAll('audio'));
            
            audios.forEach((audio, index) => {
                const hasControls = audio.hasAttribute('controls');
                const hasAccessibleName = audio.hasAttribute('aria-label') || audio.hasAttribute('aria-labelledby');
                
                if (!hasControls && !hasAccessibleName) {
                    listHtml += `<li class="ERROR">ERROR: Audio ${index + 1} is missing the <code>controls</code> attribute and an accessible name (<code>aria-label</code> or <code>aria-labelledby</code>). A separate transcript should also be considered. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(audio))}...</code></li>`;
                    issueCount++;
                }
            });
            if (audios.length > 0) {
                listHtml += `<h3>Audio Controls or Accessible Name (${audios.length} &lt;audio&gt; elements checked)</h3><ul>` + listHtml + '</ul>';
            }
            
            
            let html = `<h2>10. Media Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else if (mediaFound) {
                 html += '<p class="SUCCESS text-sm">All audio/video elements found have proper controls or captioning tracks.</p>';
            } else {
                 html += '<p class="INFO text-sm">No &lt;audio&gt; or &lt;video&gt; elements found to check.</p>';
            }
            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 11. Forms and Input Accessibility Check
        function checkFormsAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            const activeControls = Array.from(doc.querySelectorAll('input:not([type="hidden"]):not([type="submit"]):not([type="reset"]):not([type="button"]):not([type="image"]), textarea, select'));
            const controlsFound = activeControls.length > 0;

            if (!controlsFound) {
                let html = `<h2>11. Forms and Input Accessibility (${issueCount} issues)</h2>`;
                html += '<p class="INFO text-sm">No active form controls (input, select, textarea) found to check.</p>';
                resultsDiv.innerHTML += html;
                return 0;
            }

            // --- 11.1 Input Controls Missing Accessible Label ---
            const controlsWithoutLabel = activeControls.filter(control => {
                if (control.hasAttribute('aria-label') || control.hasAttribute('aria-labelledby') || control.closest('label')) {
                    return false; 
                }
                const id = control.id;
                if (id) {
                    if (doc.querySelector(`label[for="${id}"]`)) {
                        return false; 
                    }
                }
                return true;
            });
            
            issueCount += controlsWithoutLabel.length;

            if (controlsWithoutLabel.length > 0) {
                listHtml += `<h3>11.1. Input Controls Missing Accessible Name (Label/ARIA) (${controlsWithoutLabel.length} issues)</h3><ul>`;
                controlsWithoutLabel.forEach(control => {
                    listHtml += `<li class="ERROR">ERROR: Control is missing an associated <code>&lt;label&gt;</code>, <code>aria-label</code>, or <code>aria-labelledby</code>. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(control))}...</code></li>`;
                });
                listHtml += '</ul>';
            }


            // --- 11.2 Fieldset/Legend for Grouped Controls Check ---
            const groupedControls = Array.from(doc.querySelectorAll('input[type="radio"], input[type="checkbox"]'));
            
            const controlsOutsideFieldset = groupedControls.filter(control => !control.closest('fieldset'));

            if (groupedControls.length > 1 && controlsOutsideFieldset.length > 0) {
                issueCount++; // Treat as one issue if multiple controls are affected
                listHtml += `<h3>11.2. Grouped Controls Missing Fieldset/Legend (1 or more issues)</h3><ul>`;
                listHtml += `<li class="WARNING">WARNING: Found multiple radio/checkbox inputs, but ${controlsOutsideFieldset.length} are not inside a <code>&lt;fieldset&gt;</code>/<code>&lt;legend&gt;</code> block. This is needed to group related choices for screen readers.</li>`;
                controlsOutsideFieldset.forEach(control => {
                    listHtml += `<ul><li>Source Code: <code>${escapeHTML(getOpeningTag(control))}...</code></li></ul>`;
                });
                listHtml += '</ul>';
            }


            // --- 11.3 Required Attribute Mismatch Check ---
            const requiredElements = Array.from(doc.querySelectorAll('[required]'));
            
            const requiredMissingAria = requiredElements.filter(el => 
                el.getAttribute('aria-required') !== 'true'
            );

            const customRequiredElements = Array.from(doc.querySelectorAll('[aria-required="true"]:not([required])'));
            
            const totalRequiredIssues = requiredMissingAria.length + customRequiredElements.length;
            issueCount += totalRequiredIssues;

            if (totalRequiredIssues > 0) {
                listHtml += `<h3>11.3. Required Field Indicators (${totalRequiredIssues} issues)</h3><ul>`;
                if (requiredMissingAria.length > 0) {
                    listHtml += `<li class="WARNING">WARNING: ${requiredMissingAria.length} elements use the native <code>required</code> attribute but are missing the redundant (but robust) <code>aria-required="true"</code>.</li>`;
                }
                if (customRequiredElements.length > 0) {
                    listHtml += `<li class="ERROR">ERROR: ${customRequiredElements.length} elements are using <code>aria-required="true"</code> without the native <code>required</code> attribute. Ensure this is correct for your custom control.</li>`;
                }
                listHtml += '</ul>';
            }
            
            
            // --- 11.4 Autocomplete Attribute Check ---
            const relevantTokens = [
                'name', 'given-name', 'family-name', 'email', 'tel', 'password', 'organization', 
                'street-address', 'postal-code', 'country', 'cc-name', 'bday'
            ];
            
            const personalDataControls = Array.from(doc.querySelectorAll('input[type="text"], input[type="email"], input[type="tel"], input[type="url"], input[type="password"], input[type="search"], textarea, select'));
            
            const controlsToFlag = personalDataControls.filter(control => {
                const type = control.getAttribute('type') || control.tagName.toLowerCase();
                const autocomplete = control.getAttribute('autocomplete')?.toLowerCase();
                const nameId = (control.name || control.id || '').toLowerCase();
                
                // If it's a known personal data type and is missing a valid autocomplete token
                if (relevantTokens.some(token => type.includes(token.split('-')[0]) || nameId.includes(token.split('-')[0]))) {
                     if (!autocomplete || !relevantTokens.some(token => autocomplete.includes(token))) {
                         return true;
                     }
                }
                return false;
            });


            issueCount += controlsToFlag.length;

            if (controlsToFlag.length > 0) {
                listHtml += `<h3>11.4. Autocomplete Attribute Check (${controlsToFlag.length} issues)</h3><ul>`;
                controlsToFlag.forEach(control => {
                    const type = control.getAttribute('type') || control.tagName.toLowerCase();
                    const currentAutocomplete = control.getAttribute('autocomplete');
                    
                    let message = `Field type <code>${type}</code> is missing the <code>autocomplete</code> attribute, or the value (<code>${escapeHTML(currentAutocomplete || 'N/A')}</code>) is invalid. This is required for personal data inputs (WCAG 1.3.5).`;
                    
                    listHtml += `<li class="ERROR">ERROR: ${message} Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(control))}...</code></li>`;
                });
                listHtml += '</ul>';
            }
            
            
            // --- 11.5 Placeholder Reliance Check ---
            const placeholderControls = activeControls.filter(control => control.hasAttribute('placeholder'));

            const placeholderOnlyWarnings = placeholderControls.filter(control => {
                const id = control.id;
                const isVisiblyLabeled = control.closest('label') || (id && doc.querySelector(`label[for="${id}"]`));
                return !isVisiblyLabeled; 
            });

            issueCount += placeholderOnlyWarnings.length;

            if (placeholderOnlyWarnings.length > 0) {
                listHtml += `<h3>11.5. Placeholder Reliance Warning (${placeholderOnlyWarnings.length} issues)</h3><ul>`;
                placeholderOnlyWarnings.forEach(control => {
                    const placeholder = control.getAttribute('placeholder');
                    listHtml += `<li class="WARNING">WARNING: Control uses <code>placeholder="${escapeHTML(placeholder)}"</code> but is missing a permanent, visible <code>&lt;label&gt;</code>. Placeholder is not a valid substitute for a label. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(control))}...</code></li>`;
                });
                listHtml += '</ul>';
            }
            
            
            let html = `<h2>11. Forms and Input Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                 html += '<p class="SUCCESS text-sm">All active form controls appear correctly labeled and configured.</p>';
            }
            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 12. Keyboard Interaction and Focus
        function checkKeyboardFocus(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            // --- 12.1 Positive Tabindex Check ---
            const allTabindexElements = Array.from(doc.querySelectorAll('[tabindex]'));
            
            const positiveTabindexElements = allTabindexElements.filter(el => {
                const tabindexValue = parseInt(el.getAttribute('tabindex'), 10);
                return !isNaN(tabindexValue) && tabindexValue > 0;
            });

            issueCount += positiveTabindexElements.length;

            if (positiveTabindexElements.length > 0) {
                listHtml += `<h3>Positive Tabindex Found (${positiveTabindexElements.length} issues)</h3><ul>`;
                positiveTabindexElements.forEach(el => {
                    listHtml += `<li class="ERROR">ERROR: Found <code>tabindex="${el.getAttribute('tabindex')}"</code>. **Positive tabindexes (1 or greater) should be avoided** as they break the natural document focus order. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(el))}...</code></li>`;
                });
                listHtml += '</ul>';
            }


            // --- 12.2 Interactive Elements Without Semantics Check ---
            const potentialInteractiveElements = Array.from(doc.querySelectorAll('div, span, p')); 
            
            const elementsMissingSemantics = potentialInteractiveElements.filter(el => {
                const hasClickEvent = el.hasAttribute('onclick') || 
                                      el.hasAttribute('onmousedown') ||
                                      el.hasAttribute('onmouseup');
                
                if (hasClickEvent) {
                    const hasRole = el.hasAttribute('role');
                    const tabindex = el.getAttribute('tabindex');

                    if (!hasRole && tabindex !== '0') {
                        return true;
                    }
                }
                return false;
            });
            
            issueCount += elementsMissingSemantics.length;

            if (elementsMissingSemantics.length > 0) {
                listHtml += `<h3>Non-Semantic Interactive Elements (${elementsMissingSemantics.length} issues)</h3><ul>`;
                elementsMissingSemantics.forEach(el => {
                    listHtml += `<li class="ERROR">ERROR: Found <code>&lt;${el.tagName.toLowerCase()}&gt;</code> with a click handler but missing a semantic <code>role</code> (e.g., <code>role="button"</code>) and <code>tabindex="0"</code>. This element is **not keyboard accessible**. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(el))}...</code></li>`;
                });
                listHtml += '</ul>';
            }

            let html = `<h2>12. Keyboard Interaction and Focus (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                 html += '<p class="SUCCESS text-sm">Keyboard focus order appears semantic (no positive tabindexes found).</p>';
            }
            resultsDiv.innerHTML += html;
            return issueCount;
        }

    </script>
</body>
</html>
