<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A11y Quick Check</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Universal selector for dark theme, high contrast */
        * {
            color: #f3f4f6 !important; /* Set all text to light white/gray */
        }
        body {
            background-color: #1f2937; /* Dark background for the whole page */
            font-family: 'Inter', sans-serif;
            padding: 0 20px;
        }
        
        /* Structure adjustments */
        header {
            max-width: 4xl;
            margin-left: auto;
            margin-right: auto;
            padding-top: 20px;
            padding-bottom: 20px;
            border-bottom: 4px solid #4f46e5;
            text-align: center; /* Center the logo and title */
        }

        main {
            padding-top: 20px;
            padding-bottom: 40px;
            max-width: 4xl;
            margin-left: auto;
            margin-right: auto;
        }

        footer {
            max-width: 4xl;
            margin-left: auto;
            margin-right: auto;
            padding: 15px 20px;
            margin-top: 20px;
            text-align: center;
            border-top: 1px solid #374151;
            color: #9ca3af !important;
        }

        /* Skip Link Accessibility CSS */
        .skip-link {
            position: absolute;
            top: -40px; /* Hidden off-screen by default */
            left: 0;
            background: #4f46e5;
            color: white !important;
            padding: 8px 16px;
            z-index: 1000;
            border-radius: 0 0 8px 8px;
            text-decoration: none;
            font-weight: bold;
            transition: top 0.3s ease-out;
        }
        .skip-link:focus {
            top: 0; /* Visible when focused */
            outline: 4px solid #fcd34d; /* High-contrast outline */
            outline-offset: -1px;
        }

        /* Specific overrides for contrast and usability */
        #codeInput {
            color: #111827 !important; /* Input text must be dark */
            background-color: white !important; /* Input background must be light */
            resize: vertical;
            min-height: 200px;
            border: 2px solid #6b7280;
            border-radius: 8px;
        }
        button {
            background-color: #4f46e5;
            color: white !important;
            transition: background-color 0.2s;
            border-radius: 8px;
        }
        button:hover {
            background-color: #4338ca;
        }
        h1, h2, h3 {
            color: #f3f4f6 !important;
        }
        
        /* Status message colors adjusted for dark background */
        .ERROR { color: #f87171 !important; } /* Light Red */
        .WARNING { color: #fcd34d !important; } /* Light Yellow */
        .SUCCESS { color: #4ade80 !important; } /* Light Green */
        .INFO { color: #9ca3af !important; } /* Muted Light Gray */
        
        #results ul {
            list-style-type: none;
            padding-left: 1rem;
        }
        #results li {
            margin-bottom: 5px;
            padding-left: 1.5rem;
            position: relative;
        }
        #results li:before {
            content: '•';
            position: absolute;
            left: 0;
            color: #4f46e5; /* Keep the bullet color consistent */
            font-weight: bold;
        }
        /* Styling for the displayed code within the collapsible section */
        .formatted-code {
            color: #60a5fa !important; /* Light blue code text */
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.4;
            white-space: pre-wrap; /* Allows long lines to wrap */
            word-wrap: break-word; /* Ensures long words are broken */
        }
        code {
            background-color: #374151; /* Darker background for code snippets */
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.875rem;
            color: #60a5fa !important; /* Light blue code text */
        }
    </style>
</head>
<body>

    <a href="#main-content" class="skip-link">Skip to Main Content</a>

    <header>
        <div class="flex flex-col items-center justify-center gap-4">
            <img src="https://placehold.co/100x40/4f46e5/ffffff?text=A11y+Audit" alt="A11y Quick Check Logo" class="rounded-lg shadow-xl">
            <h1 class="text-4xl font-extrabold text-white">A11y Quick Check</h1>
        </div>
    </header>

    <main id="main-content">
        <h2 class="text-3xl font-bold mb-6 border-b-2 border-gray-600 pb-2">Start Your Accessibility Audit</h2>
        
        <div class="mb-6 p-4 bg-gray-700 border-l-4 border-indigo-400 rounded-lg text-sm text-gray-50">
            <h3 class="text-xl font-bold mb-2 border-b-0 text-white !important">Method 1: Instant Audit via Bookmarklet ⚡️</h3>
            <p class="mb-2">This is the fastest way to check any live page. Save the code below as a bookmark. When you click it, you will get a choice:</p>
            <ul class="list-disc pl-5 mb-2">
                <li>**Analyze in New Tab (Click OK):** Analyzes the page here, in the full tool.</li>
                <li>**Analyze Here (Click CANCEL):** Instantly runs the audit on the current page. Results are injected for screen readers and shown on hover.</li>
            </ul>
            <p class="font-semibold mb-1 text-white">Bookmarklet Code (Drag-and-Drop or Copy):</p>
            
<textarea readonly id="bookmarkletCode" class="w-full p-2 text-xs text-gray-900 bg-gray-200 rounded-md select-all" rows="4">javascript:(function(){const toolUrl='https://dilippariyar.github.io/a11y-quick-check/';if(window.confirm("Where do you want to see the results?\n\n- Click 'OK' to analyze in a NEW TAB.\n- Click 'CANCEL' to analyze HERE.")){const code=encodeURIComponent(document.documentElement.outerHTML);window.open(toolUrl+'#code='+code,'_blank');}else{const s=document.createElement('script');s.src=toolUrl+'run-on-page.js?v='+Date.now();document.head.append(s);}})();</textarea>
            <p class="mt-2 text-xs text-gray-400">**Current Tool URL**: <code>https://dilippariyar.github.io/a11y-quick-check/</code></p>
        </div>            <p class="mt-2 text-xs text-gray-400">**Current Tool URL**: <code>https://dilippariyar.github.io/a11y-quick-check/</code></p>
        </div>
        
        <div class="mb-6 p-4 bg-gray-700 border-l-4 border-indigo-400 rounded-lg text-sm text-gray-50">
            <h3 class="text-xl font-bold mb-1 text-white">Method 2: Manual Source Code Input</h3>
            <p>If you prefer or need to check a local file, simply **copy and paste** the full HTML source code from the target page into the editor below.</p>
            <p class="mt-2">*(Tip: In most browsers, press Control + U or Cmd + Option + U to view the source code.)*</p>
        </div>


        <label for="codeInput" class="block mb-2 font-medium">
            Paste the HTML **Source Code** or wait for the Bookmarklet to auto-fill.
        </label>

        <textarea id="codeInput" rows="20" class="w-full p-4 text-sm focus:ring-indigo-500 focus:border-indigo-500 shadow-sm"></textarea>
        
        <button onclick="checkAccessibility()" class="w-full py-3 px-6 text-lg font-semibold shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50">
            Run Accessibility Audit
        </button>
        
        <button id="downloadBtn" onclick="downloadResults()" class="w-full py-3 px-6 text-lg font-semibold shadow-lg focus:outline-none mt-2 bg-green-600 hover:bg-green-700 hidden" accesskey="r">
            Download Audit Results (<span class="font-bold underline">Alt+R</span>)
        </button>

        <div id="live-announcer" aria-live="polite" role="status" style="position: absolute; clip: rect(1px, 1px, 1px, 1px); padding: 0; border: 0; height: 1px; width: 1px; overflow: hidden;"></div>

        <div id="results" class="pb-4">
            <p class="INFO text-lg font-medium">Results will appear here after the audit runs.</p>
        </div>
        
        <div id="codeSourceContainer" class="mt-8 pt-4 border-t-2 border-gray-600 hidden">
            <h2 class="text-2xl font-bold mb-4">View Source Code for Learners</h2>
            <details id="sourceCodeDetails" class="rounded-lg shadow-xl overflow-hidden bg-gray-700">
                <summary class="cursor-pointer p-4 text-xl font-bold bg-indigo-600 hover:bg-indigo-700 rounded-lg focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50">
                    View and Inspect the Source Code
                </summary>
                <div id="formattedCodeDisplay" class="p-4 text-xs"></div>
            </details>
        </div>
    </main>
    
    <footer>
        <p class="text-sm font-semibold">Accessibility is not optional—it's foundational design.</p>
        <p class="mt-1 text-xs text-gray-400">This tool helps you quickly check for common violations of **WCAG 2.2** principles.</p>
        <p class="mt-1 text-xs text-gray-400">Built for developers and auditors, with a focus on keyboard and screen reader compliance.</p>
        <p class="mt-2 text-xs text-gray-400 font-medium">(designed and developed by Dilip Pariyar)</p>
    </footer>

    <script>
        
        // --- UTILITY FUNCTIONS ---
        
        // Helper function to safely display HTML code snippets (Escape < and >)
        function escapeHTML(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&#039;');
        }
        
        // Helper function to return the opening tag and attributes, plus a small content snippet
        function getOpeningTag(el) {
            // 1. Get the tag name
            const tagName = el.tagName.toLowerCase();
            
            // 2. Get all attributes as a string
            const attributes = Array.from(el.attributes)
                .map(attr => `${attr.name}="${attr.value}"`)
                .join(' ');
                
            // 3. Construct the opening tag string
            let openingTag = `<${tagName}`;
            if (attributes) {
                openingTag += ' ' + attributes;
            }
            openingTag += '>';
            
            // 4. Optionally append a short snippet of content
            const contentSnippet = el.textContent.trim().substring(0, 50);
            if (contentSnippet) {
                // If content is very long, use '...'
                const ellipsis = el.textContent.trim().length > 50 ? '...' : '';
                openingTag += ellipsis + escapeHTML(contentSnippet) + ellipsis;
            }
            
            return openingTag;
        }

        // --- AUTORUN LOGIC FOR BOOKMARKLET ---
        window.onload = function() {
            const hash = window.location.hash;
            const codeInput = document.getElementById('codeInput');
            const liveAnnouncer = document.getElementById('live-announcer');

            // Check if the URL contains the code payload from the bookmarklet
            if (hash.startsWith('#code=')) {
                try {
                    // Extract and decode the source code
                    const encodedCode = hash.substring(6);
                    const decodedCode = decodeURIComponent(encodedCode);
                    
                    if (decodedCode.trim().length > 0) {
                        codeInput.value = decodedCode;
                        
                        // Clear the hash from the URL to allow rerunning the bookmarklet later
                        history.replaceState(null, null, ' ');
                        
                        // Announce and automatically run the audit
                        liveAnnouncer.textContent = 'Source code loaded automatically. Running accessibility audit now.';
                        checkAccessibility();
                    }
                } catch (e) {
                    liveAnnouncer.textContent = 'Failed to load source code from URL hash due to an encoding error.';
                    console.error("Decoding error:", e);
                }
            }
        };


        
        // Helper function to create an accessible region for the displayed source code
        function createCodeRegion(title, code, role, isMissing) {
            // Only render the section if code is found or if it is the "missing forms" info message
            if (!code.trim() && !isMissing) return ''; 

            const sectionClass = isMissing ? "bg-gray-800 border-gray-600" : "bg-gray-800 border-indigo-500";
            const codeContent = code.trim() || `--- ${title} Not Found. Searching for corresponding tags or roles. ---`;
            
            // Use a <section> element as requested, with region role and heading for navigation
            return `
                <section role="region" aria-label="${title}" class="p-3 mb-4 rounded-lg border-l-4 ${sectionClass}">
                    <h3 class="text-lg font-bold mb-2 text-white !important">${title}</h3>
                    <pre class="formatted-code p-3 bg-gray-900 rounded-md text-xs overflow-auto">
                        <code class="text-blue-300">
${escapeHTML(codeContent)}
                        </code>
                    </pre>
                </section>
            `;
        }


        // Function to display the source code in the collapsible section, now structured by accessible region
        function displayFormattedCode(code) {
            const container = document.getElementById('codeSourceContainer');
            const displayElement = document.getElementById('formattedCodeDisplay');
            displayElement.innerHTML = ''; // Clear previous content

            const parser = new DOMParser();
            const doc = parser.parseFromString(code, 'text/html');
            const bodyContent = doc.body ? doc.body.innerHTML : ''; // Get the full content inside <body>

            let outputHtml = `
                <p class="INFO text-sm mb-4 border-b pb-2 border-gray-600">
                    The HTML is extracted and grouped into semantic **regions** for efficient screen reader navigation.
                </p>
            `;

            // 1. Identify key landmarks
            const headerEl = doc.querySelector('header, [role="banner"]');
            const mainEl = doc.querySelector('main, [role="main"]');
            const footerEl = doc.querySelector('footer, [role="contentinfo"]');
            const formEls = doc.querySelectorAll('form');
            const navEls = doc.querySelectorAll('nav, [role="navigation"]');
            
            // CHECK FOR FALLBACK SCENARIO: Are all three major structural landmarks missing?
            const allMajorLandmarksMissing = !headerEl && !mainEl && !footerEl;

            if (allMajorLandmarksMissing) {
                // FALLBACK: Show the entire body content as one block
                outputHtml += createCodeRegion(
                    'Full Document Body (No Major Landmarks Found)', 
                    bodyContent, 
                    'body', 
                    false // It's not missing, it's the fallback content
                );
                outputHtml += `
                    <p class="WARNING text-sm mt-4 p-3 bg-red-900/50 rounded-lg">
                        WARNING: Since no <code>&lt;header&gt;</code>, <code>&lt;main&gt;</code>, or <code>&lt;footer&gt;</code> landmarks were found, the entire content of the <code>&lt;body&gt;</code> is displayed here. Adding these semantic landmarks is highly recommended for accessibility.
                    </p>
                `;
            } else {
                // NORMAL SCENARIO: Display segmented regions (as before)

                // 2. HEADER Region
                const headerCode = headerEl ? headerEl.outerHTML : '';
                outputHtml += createCodeRegion('Header Region (Landmark: banner)', headerCode, 'banner', !headerEl);
                
                // 3. NAV Region
                let navCode = '';
                if (navEls.length > 0) {
                    navEls.forEach((navEl, index) => {
                        const navId = navEl.id ? `ID: ${navEl.id}` : `No ID`;
                        const role = navEl.getAttribute('role') || 'nav element';
                        navCode += `\n\n`;
                        navCode += navEl.outerHTML;
                        navCode += `\n\n`;
                    });
                    outputHtml += createCodeRegion(`Navigation Regions (${navEls.length} found - Landmark: navigation)`, navCode, 'navigation', false);
                } else {
                     outputHtml += createCodeRegion('Navigation Regions (0 found)', '--- No &lt;nav&gt; or role="navigation" elements were found. ---', 'navigation', true);
                }

                // 4. MAIN Region
                const mainCode = mainEl ? mainEl.outerHTML : '';
                outputHtml += createCodeRegion('Main Region (Landmark: main)', mainCode, 'main', !mainEl);

                // 5. FORM Regions (Multiple) - Still useful even if other landmarks exist
                let formCode = '';
                if (formEls.length > 0) {
                    formEls.forEach((formEl, index) => {
                        const formId = formEl.id ? `ID: ${formEl.id}` : `No ID`;
                        formCode += `\n\n`;
                        formCode += formEl.outerHTML;
                        formCode += `\n\n`;
                    });
                    outputHtml += createCodeRegion(`Form Regions (${formEls.length} found)`, formCode, 'form', false);
                } else {
                     outputHtml += createCodeRegion('Form Regions (0 forms found)', '--- No &lt;form&gt; elements were found in the source code. ---', 'form', true);
                }

                // 6. FOOTER Region
                const footerCode = footerEl ? footerEl.outerHTML : '';
                outputHtml += createCodeRegion('Footer Region (Landmark: contentinfo)', footerCode, 'contentinfo', !footerEl);
            }

            // Set the content and show the container
            if (container && displayElement) {
                displayElement.innerHTML = outputHtml;
                // document.getElementById('sourceCodeDetails').open = true; // REMOVED: Keeps it collapsed by default
                container.classList.remove('hidden');
            }
        }

        // Main function to run all accessibility checks
        function checkAccessibility() {
            const htmlCode = document.getElementById('codeInput').value;
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = ''; // Clear previous results
            const downloadBtn = document.getElementById('downloadBtn');

            if (!htmlCode.trim()) {
                resultsDiv.innerHTML = '<p class="ERROR font-semibold">Please enter some HTML source code to run the audit.</p>';
                document.getElementById('live-announcer').textContent = 'Audit requires input code.';
                downloadBtn.classList.add('hidden'); // Hide on failure
                return;
            }

            let totalAuditIssues = 0;

            try {
                const parser = new DOMParser();
                // Use 'text/html' to parse the snippet as a full document
                const doc = parser.parseFromString(htmlCode, 'text/html');

                // Run each audit section and accumulate issues
                totalAuditIssues += checkDocumentBasics(doc, resultsDiv);
                totalAuditIssues += checkHeadingStructure(doc, resultsDiv);
                totalAuditIssues += checkAriaLandmarks(doc, resultsDiv);
                totalAuditIssues += checkImgRoleImgAccessibility(doc, resultsDiv);
                totalAuditIssues += checkGraphicsAndIconsAccessibility(doc, resultsDiv); 
                totalAuditIssues += checkButtonAccessibility(doc, resultsDiv);
                totalAuditIssues += checkLinkAccessibility(doc, resultsDiv);
                totalAuditIssues += checkTableAccessibility(doc, resultsDiv);
                totalAuditIssues += checkIframeAccessibility(doc, resultsDiv);
                totalAuditIssues += checkMediaAccessibility(doc, resultsDiv);
                totalAuditIssues += checkFormsAccessibility(doc, resultsDiv); 
                totalAuditIssues += checkKeyboardFocus(doc, resultsDiv);
                totalAuditIssues += checkFormIdUniqueness(doc, resultsDiv); 
                
                // Display the original code in the collapsible section (new feature)
                displayFormattedCode(htmlCode);


                if (totalAuditIssues === 0) {
                    resultsDiv.innerHTML = '<p class="SUCCESS font-semibold">No issues found based on the implemented checks. Great job!</p>' + resultsDiv.innerHTML;
                }
                
                
                // Show download button on successful audit
                downloadBtn.classList.remove('hidden');

            } catch (error) {
                // Clear all previous results and show the parsing error
                resultsDiv.innerHTML = `<h3 class="ERROR text-xl font-bold mb-2">Parsing Error</h3><p class="ERROR">Could not parse the provided HTML source code: ${escapeHTML(error.message)}</p>`;
                console.error("Parsing error:", error);
                downloadBtn.classList.add('hidden'); // Hide on parsing error
            }

            // ARIA Live Announcement when complete with total issues
            document.getElementById('live-announcer').textContent = `Accessibility audit complete. Found ${totalAuditIssues} potential issues.`;
        }
        
        // --- START OF AUDIT FUNCTIONS ---
        // (All 13 audit functions: checkFormIdUniqueness, checkDocumentBasics, 
        // checkHeadingStructure, checkAriaLandmarks, checkImgRoleImgAccessibility,
        // checkGraphicsAndIconsAccessibility, checkButtonAccessibility, 
        // checkLinkAccessibility, checkTableAccessibility, checkIframeAccessibility,
        // checkMediaAccessibility, checkFormsAccessibility, checkKeyboardFocus
        // ... ALL REMAIN IDENTICAL TO YOUR FILE ... )

        // 13. ID Uniqueness Check
        function checkFormIdUniqueness(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            const allElementsWithId = Array.from(doc.querySelectorAll('[id]'));
            const idMap = new Map();

            // 1. Map IDs to elements
            allElementsWithId.forEach(el => {
                const id = el.id.trim();
                if (id) {
                    if (!idMap.has(id)) {
                        idMap.set(id, []);
                    }
                    idMap.get(id).push(el);
                }
            });

            // 2. Identify and report duplicates
            const duplicateIds = Array.from(idMap.entries()).filter(([, elements]) => elements.length > 1);
            issueCount = duplicateIds.length;

            let html = `<h2>13. ID Uniqueness Check (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                listHtml += '<ul><li class="ERROR">ERROR: Found duplicate <code>id</code> attributes. The <code>id</code> **must be unique** in the document. Duplicate IDs cause labels (and ARIA relationships) to target the wrong element.</li>';
                
                duplicateIds.forEach(([id, elements]) => {
                    listHtml += '<ul><li>**Duplicate ID**: <code>' + escapeHTML(id) + '</code> (' + elements.length + ' occurrences):';
                    listHtml += '<ul>';
                    elements.forEach(el => {
                        const openingTag = getOpeningTag(el);
                        listHtml += `<li class="ERROR">Source Code (Opening Tag): <code>${escapeHTML(openingTag)}</code></li>`;
                    });
                    listHtml += '</ul></li></ul>';
                });
                listHtml += '</ul>';
                html += listHtml;
            } else {
                 html += '<p class="SUCCESS text-sm">No duplicate <code>id</code> attributes found.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 1. Document Basics Check
        function checkDocumentBasics(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            // 1.1 Page Title (<title>)
            const pageTitle = doc.querySelector('title')?.textContent;
            if (!pageTitle || pageTitle.trim().length === 0) {
                listHtml += `<li class="WARNING">WARNING: Page Title (&lt;title&gt;) is missing or empty. This is crucial for context.</li>`;
                issueCount++;
            }

            // 1.2 Page Language (lang attribute on <html>)
            const htmlTag = doc.querySelector('html');
            const langAttr = htmlTag ? htmlTag.getAttribute('lang') : null;

            if (!langAttr || langAttr.trim().length < 2) {
                listHtml += '<li class="ERROR">ERROR: Page language (<code>lang</code> attribute on the <code>&lt;html&gt;</code> tag) is missing or invalid. This is required for screen readers (WCAG 3.1.1).</li>';
                issueCount++;
            }

            // 1.3 Skip to Main Content (Link)
            const skipLink = doc.querySelector('a[href*="#"][href*="main"], a[href*="#content"]');
            if (!skipLink) {
                listHtml += '<li class="WARNING">WARNING: "Skip to main content" link not found. Consider adding one for keyboard users.</li>';
                issueCount++;
            }
            
            let html = `<h2>1. Document Basics (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">Document Basics (Title, Lang, Skip Link) check passed.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 2. Heading Structure Check
        function checkHeadingStructure(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 
            
            const headings = Array.from(doc.querySelectorAll('h1, h2, h3, h4, h5, h6'));
            const headingLevels = headings.map(h => parseInt(h.tagName.substring(1)));

            // H1 availability and count
            const h1Count = headingLevels.filter(level => level === 1).length;
            
            // Heading Level Skip
            for (let i = 0; i < headingLevels.length - 1; i++) {
                const currentLevel = headingLevels[i];
                const nextLevel = headingLevels[i+1];
                if (nextLevel > currentLevel + 1) {
                    listHtml += `<li class="ERROR">ERROR: Heading level skipped! Found &lt;h${currentLevel}&gt; followed by &lt;h${nextLevel}&gt;. You skipped level(s) up to &lt;h${currentLevel + 1}&gt;.`;
                    listHtml += `<ul><li>Source Code Snippet: &lt;h${currentLevel}&gt;... followed by &lt;h${nextLevel}&gt;...</li></ul></li>`;
                    issueCount++;
                }
            }

            let html = `<h2>2. Heading Structure (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">Heading structure and usage is correct.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 3. ARIA Landmark Check (UPDATED)
        function checkAriaLandmarks(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';

            const primaryLandmarks = [
                { name: 'Header/Banner', selector: 'header, [role="banner"]', tag: '&lt;header&gt; or role="banner"' },
                { name: 'Main', selector: 'main, [role="main"]', tag: '&lt;main&gt; or role="main"' },
                { name: 'Footer/Contentinfo', selector: 'footer, [role="contentinfo"]', tag: '&lt;footer&gt; or role="contentinfo"' },
            ];
            
            // Separate check for Navigation and count
            const navElements = Array.from(doc.querySelectorAll('nav, [role="navigation"]'));
            const navCount = navElements.length;

            primaryLandmarks.forEach(landmark => {
                const element = doc.querySelector(landmark.selector);
                if (!element) {
                    listHtml += `<li class="WARNING">WARNING: ${landmark.name} is missing. Use ${landmark.tag} to define this landmark.</li>`;
                    issueCount++;
                }
            });
            
            // Add Navigation check and count info (Requirement 1 Fix)
            if (navCount === 0) {
                 listHtml += `<li class="WARNING">WARNING: Navigation Landmark is missing. Use &lt;nav&gt; or role="navigation" to define navigation regions.</li>`;
                 issueCount++;
            } else if (navCount > 1) {
                 // Check if multiple navigation landmarks are labeled
                 const unlabeledNavs = navElements.filter(el => !el.hasAttribute('aria-label') && !el.hasAttribute('aria-labelledby'));
                 if (unlabeledNavs.length > 0) {
                      listHtml += `<li class="WARNING">WARNING: Found ${navCount} navigation regions, but ${unlabeledNavs.length} are unlabeled. Multiple &lt;nav&gt; elements require unique <code>aria-label</code> or <code>aria-labelledby</code> attributes.</li>`;
                      issueCount += unlabeledNavs.length;
                 }
            }

            let html = `<h2>3. ARIA Landmarks (${issueCount} issues)</h2>`;
            // Report the Navigation count clearly
            html += `<p class="INFO text-sm font-semibold">Navigation Regions Found: ${navCount} (Defined by <code>&lt;nav&gt;</code> or <code>role="navigation"</code>).</p>`; 
            
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">All required ARIA Landmarks (Header, Main, Footer, Nav) are present and correctly used.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 4. Image Accessibility Check (Focus on <img> and role="img")
        function checkImgRoleImgAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            
            const imgRoleImgElements = Array.from(doc.querySelectorAll('img, [role="img"]'));
            const totalImgsFound = imgRoleImgElements.length;

            const imgs = Array.from(doc.querySelectorAll('img'));

            const imgsWithoutAlt = imgs.filter(img => !img.hasAttribute('alt'));
            const imgsWithEmptyAlt = imgs.filter(img => img.hasAttribute('alt') && img.getAttribute('alt').trim() === '');
            
            issueCount += imgsWithoutAlt.length + imgsWithEmptyAlt.length;

            let html = `<h2>4. Image Accessibility (${issueCount} issues)</h2>`;
            
            if (totalImgsFound > 0) {
                 html += `<p class="INFO text-sm">Total <code>&lt;img&gt;</code> or <code>role="img"</code> elements found: ${totalImgsFound}</p>`;
            }


            if (imgsWithoutAlt.length > 0) {
                listHtml += `<h3>&lt;img&gt; without 'alt' attribute (${imgsWithoutAlt.length} issues)</h3><ul>`;
                imgsWithoutAlt.forEach(img => {
                    listHtml += `<li class="ERROR">ERROR: Missing 'alt'. Source Code: <code>${escapeHTML(img.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }

            if (imgsWithEmptyAlt.length > 0) {
                listHtml += `<h3>&lt;img&gt; with empty 'alt' attribute (alt="") (${imgsWithEmptyAlt.length} issues)</h3><ul>`;
                imgsWithEmptyAlt.forEach(img => {
                    listHtml += `<li class="WARNING">WARNING: Empty 'alt' (<code>alt=""</code>) suggests the image is decorative. Use this deliberately. Source Code: <code>${escapeHTML(img.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }
            
            
            if (issueCount > 0) {
                html += listHtml;
            } else if (totalImgsFound > 0) {
                 html += '<p class="SUCCESS text-sm">All images found have appropriate <code>alt</code> text applied.</p>';
            } else {
                 html += '<p class="INFO text-sm">No <code>&lt;img&gt;</code> or <code>role="img"</code> elements found to check.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }
        
        // 5. Icons, SVG, and Canvas Accessibility Check
        function checkGraphicsAndIconsAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            const allElements = Array.from(doc.querySelectorAll('*')); 

            // --- 5.1 ICON CHECK (e.g., Font Awesome) ---
            const iconElements = allElements.filter(el => 
                (el.tagName === 'I' || el.tagName === 'SPAN') && el.className.includes('fa-')
            );

            const iconIssues = iconElements.filter(el => {
                const isHidden = el.getAttribute('aria-hidden') === 'true';
                const hasLabel = el.hasAttribute('aria-label') || el.hasAttribute('aria-labelledby');
                return !isHidden && !hasLabel;
            });
            
            issueCount += iconIssues.length;

            if (iconIssues.length > 0) {
                listHtml += `<h3>Icon Elements Missing Label or Hidden (${iconIssues.length} issues)</h3><ul>`;
                iconIssues.forEach(el => {
                    listHtml += `<li class="WARNING">WARNING: Icon found that is neither hidden (<code>aria-hidden="true"</code>) nor labeled (<code>aria-label</code> or <code>aria-labelledby</code>). Source Code: <code>${escapeHTML(el.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }


            // --- 5.2 SVG CHECK ---
            const svgElements = Array.from(doc.querySelectorAll('svg'));
            const svgIssues = svgElements.filter(svg => {
                const isHidden = svg.getAttribute('aria-hidden') === 'true';
                const hasAriaLabel = svg.hasAttribute('aria-label') || svg.hasAttribute('aria-labelledby');
                const hasTitle = svg.querySelector('title') !== null;
                
                return !isHidden && !hasAriaLabel && !hasTitle;
            });

            issueCount += svgIssues.length;

            if (svgIssues.length > 0) {
                listHtml += `<h3>SVG Accessibility (${svgIssues.length} issues)</h3><ul>`;
                svgIssues.forEach(svg => {
                    listHtml += `<li class="WARNING">WARNING: Non-decorative &lt;svg&gt; element is missing accessible name (&lt;title&gt;, <code>aria-label</code>, or <code>aria-labelledby</code>). Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(svg))}</code></li>`;
                });
                listHtml += '</ul>';
            }

            
            // --- 5.3 CANVAS CHECK ---
            const canvasElements = Array.from(doc.querySelectorAll('canvas'));
            const canvasIssues = canvasElements.filter(canvas => {
                const hasFallback = canvas.innerHTML.trim().length > 0;
                const hasAriaLabel = canvas.hasAttribute('aria-label') || canvas.hasAttribute('aria-labelledby');

                return !hasFallback && !hasAriaLabel;
            });

            issueCount += canvasIssues.length;

            if (canvasIssues.length > 0) {
                listHtml += `<h3>Canvas Accessibility (${canvasIssues.length} issues)</h3><ul>`;
                canvasIssues.forEach(canvas => {
                    listHtml += `<li class="ERROR">ERROR: &lt;canvas&gt; is missing visible fallback content and accessible name (<code>aria-label</code> or <code>aria-labelledby</code>). Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(canvas))}</code></li>`;
                });
                listHtml += '</ul>';
            }

            
            let html = `<h2>5. Icons, SVG, and Canvas Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                html += '<p class="SUCCESS text-sm">Icons, SVGs, and Canvas elements are correctly hidden or labeled.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 6. Button Accessibility Check (UPDATED - FIXES FALSE POSITIVE)
        function checkButtonAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 
            
            // --- 6.1 Native <button> without accessible name ---
            const nativeButtons = Array.from(doc.querySelectorAll('button'));
            const noLabelNativeButtons = nativeButtons.filter(btn => {
                const hasVisibleText = btn.textContent.trim().length > 0;
                const hasAriaLabel = btn.hasAttribute('aria-label') || btn.hasAttribute('aria-labelledby');
                return !hasVisibleText && !hasAriaLabel;
            });
            
            issueCount += noLabelNativeButtons.length;

            if (noLabelNativeButtons.length > 0) {
                listHtml += `<h3>Native &lt;button&gt; without Accessible Name (${noLabelNativeButtons.length} issues)</h3><ul>`;
                noLabelNativeButtons.forEach(btn => {
                    listHtml += `<li class="ERROR">ERROR: &lt;button&gt; has no visible text and is missing <code>aria-label</code> or <code>aria-labelledby</code>. Source Code: <code>${escapeHTML(btn.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }


            // --- 6.2 Custom role="button" Check (FIXED LOGIC) ---
            const customButtons = Array.from(doc.querySelectorAll('[role="button"]'));
            
            // Filter to find elements that have role="button" BUT are NOT native <button> tags
            // AND are missing tabindex="0" (the requirement for custom buttons)
            const noTabIndexButtons = customButtons.filter(btn => {
                 const isNativeButton = btn.tagName === 'BUTTON';
                 const isMissingTabIndex = btn.getAttribute('tabindex') !== '0';

                 // ONLY flag elements that are NOT native buttons and are missing tabindex="0"
                 // This correctly IGNORES native buttons even if they also have role="button"
                 return !isNativeButton && isMissingTabIndex;
            });

            issueCount += noTabIndexButtons.length; 

            if (noTabIndexButtons.length > 0) {
                listHtml += `<h3>Custom role="button" without tabindex="0" (${noTabIndexButtons.length} issues)</h3><ul>`;
                noTabIndexButtons.forEach(btn => {
                    listHtml += `<li class="ERROR">ERROR: Custom button element (e.g., &lt;div role="button"&gt;) is missing <code>tabindex="0"</code>, making it unfocusable by keyboard. Native &lt;button&gt; elements with this role were ignored (FIXED). Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(btn))}</code></li>`;
                });
                listHtml += '</ul>';
            }
            
            // Final H2 with total issue count
            let html = `<h2>6. Button Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                html += '<p class="SUCCESS text-sm">All button elements appear to be correctly labeled and keyboard accessible.</p>';
            }
            resultsDiv.innerHTML += html;

            return issueCount;
        }

        // 7. Link Accessibility Check
        function checkLinkAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            
            const genericTexts = [
                "learn more", "read more", "view more", "click here", "go", "link", 
                "details", "here", "more", "find out"
            ];

            const links = Array.from(doc.querySelectorAll('a'));
            
            const genericLinks = links.filter(link => {
                const text = link.textContent.trim().toLowerCase();
                
                if (link.getAttribute('aria-hidden') === 'true' || link.hasAttribute('aria-label') || link.hasAttribute('aria-labelledby')) {
                    return false;
                }

                const isGeneric = genericTexts.some(generic => {
                    if (text === generic) return true;
                    return text.startsWith(generic + ' ') || text.endsWith(' ' + generic) || text.includes(' ' + generic + ' ');
                });

                return isGeneric;
            });

            issueCount = genericLinks.length;

            if (genericLinks.length > 0) {
                listHtml += `<h3>Generic Link Text Found (${genericLinks.length} issues)</h3><ul>`;
                genericLinks.forEach(link => {
                    const linkText = link.textContent.trim();
                    listHtml += `<li class="ERROR">ERROR: Link text "<strong>${escapeHTML(linkText)}</strong>" is generic and lacks context when read out of context. Consider rewriting or adding <code>aria-label</code>. Source Code: <code>${escapeHTML(link.outerHTML)}</code></li>`;
                });
                listHtml += '</ul>';
            }

            let html = `<h2>7. Link Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                html += '<p class="SUCCESS text-sm">No overly generic link text was found.</p>';
            }
            resultsDiv.innerHTML += html;

            return issueCount;
        }


        // 8. Table Accessibility Check
        function checkTableAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            const tables = Array.from(doc.querySelectorAll('table'));

            tables.forEach((table, index) => {
                const hasTh = table.querySelector('th');
                const hasColScope = table.querySelector('th[scope="col"]');
                const hasRowScope = table.querySelector('th[scope="row"]');
                
                if (!hasTh) {
                    listHtml += `<li class="ERROR">ERROR: Table ${index + 1} is missing semantic header tags (<code>&lt;th&gt;</code>). Headers are essential for navigation and context. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(table))}</code></li>`;
                    issueCount++;
                } 
                else if (!hasColScope && !hasRowScope && hasTh) {
                    listHtml += `<li class="WARNING">WARNING: Table ${index + 1} uses <code>&lt;th&gt;</code> but lacks explicit <code>scope="col"</code> or <code>scope="row"</code> attributes. Consider adding scope for clear structure. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(table))}</code></li>`;
                    issueCount++;
                }
            });

            let html = `<h2>8. Table Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">Table structure appears sound (or no tables were found).</p>';
            }
            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 9. Iframe Accessibility Check
        function checkIframeAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            const iframes = Array.from(doc.querySelectorAll('iframe'));

            iframes.forEach((iframe, index) => {
                const title = iframe.getAttribute('title');
                
                if (!title || title.trim() === '') {
                    listHtml += `<li class="ERROR">ERROR: Iframe ${index + 1} is missing a non-empty <code>title</code> attribute. This title is essential for screen reader users to understand the frame's content. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(iframe))}</code></li>`;
                    issueCount++;
                }
            });

            let html = `<h2>9. Iframe Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += '<ul>' + listHtml + '</ul>';
            } else {
                html += '<p class="SUCCESS text-sm">All iframes (or none) have a valid <code>title</code> attribute.</p>';
            }
            resultsDiv.innerHTML += html;
            return issueCount;
        }
        
        // 10. Media Accessibility Check
        function checkMediaAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            const mediaFound = doc.querySelectorAll('video, audio').length > 0;

            // --- 10.1 Video Captions/Subtitles Check ---
            const videos = Array.from(doc.querySelectorAll('video'));
            
            videos.forEach((video, index) => {
                const hasCaptions = video.querySelector('track[kind="captions"], track[kind="subtitles"]');
                
                if (!hasCaptions) {
                    listHtml += `<li class="ERROR">ERROR: Video ${index + 1} is missing a <code>&lt;track&gt;</code> element for captions or subtitles. This is essential for deaf users. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(video))}</code></li>`;
                    issueCount++;
                }
            });
            if (videos.length > 0) {
                listHtml += `<h3>Video Captions/Subtitles (${videos.length} &lt;video&gt; elements checked)</h3><ul>` + listHtml + '</ul>';
            }


            // --- 10.2 Audio Controls/Transcript Check ---
            const audios = Array.from(doc.querySelectorAll('audio'));
            
            audios.forEach((audio, index) => {
                const hasControls = audio.hasAttribute('controls');
                const hasAccessibleName = audio.hasAttribute('aria-label') || audio.hasAttribute('aria-labelledby');
                
                if (!hasControls && !hasAccessibleName) {
                    listHtml += `<li class="ERROR">ERROR: Audio ${index + 1} is missing the <code>controls</code> attribute and an accessible name (<code>aria-label</code> or <code>aria-labelledby</code>). A separate transcript should also be considered. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(audio))}</code></li>`;
                    issueCount++;
                }
            });
            if (audios.length > 0) {
                listHtml += `<h3>Audio Controls or Accessible Name (${audios.length} &lt;audio&gt; elements checked)</h3><ul>` + listHtml + '</ul>';
            }
            
            
            let html = `<h2>10. Media Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else if (mediaFound) {
                 html += '<p class="SUCCESS text-sm">All audio/video elements found have proper controls or captioning tracks.</p>';
            } else {
                 html += '<p class="INFO text-sm">No &lt;audio&gt; or &lt;video&gt; elements found to check.</p>';
            }
            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 11. Forms and Input Accessibility Check
        function checkFormsAccessibility(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = ''; 

            const activeControls = Array.from(doc.querySelectorAll('input:not([type="hidden"]):not([type="submit"]):not([type="reset"]):not([type="button"]):not([type="image"]), textarea, select'));
            const controlsFound = activeControls.length > 0;

            if (!controlsFound) {
                let html = `<h2>11. Forms and Input Accessibility (${issueCount} issues)</h2>`;
                html += '<p class="INFO text-sm">No active form controls (input, select, textarea) found to check.</p>';
                resultsDiv.innerHTML += html;
                return 0;
            }

            // --- 11.1 Input Controls Missing Accessible Label ---
            const controlsWithoutLabel = activeControls.filter(control => {
                if (control.hasAttribute('aria-label') || control.hasAttribute('aria-labelledby') || control.closest('label')) {
                    return false; 
                }
                const id = control.id;
                if (id) {
                    if (doc.querySelector(`label[for="${id}"]`)) {
                        return false; 
                    }
                }
                return true;
            });
            
            issueCount += controlsWithoutLabel.length;

            if (controlsWithoutLabel.length > 0) {
                listHtml += `<h3>11.1. Input Controls Missing Accessible Name (Label/ARIA) (${controlsWithoutLabel.length} issues)</h3><ul>`;
                controlsWithoutLabel.forEach(control => {
                    listHtml += `<li class="ERROR">ERROR: Control is missing an associated <code>&lt;label&gt;</code>, <code>aria-label</code>, or <code>aria-labelledby</code>. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(control))}</code></li>`;
                });
                listHtml += '</ul>';
            }


            // --- 11.2 Fieldset/Legend for Grouped Controls Check ---
            const groupedControls = Array.from(doc.querySelectorAll('input[type="radio"], input[type="checkbox"]'));
            
            const controlsOutsideFieldset = groupedControls.filter(control => !control.closest('fieldset'));

            if (groupedControls.length > 1 && controlsOutsideFieldset.length > 0) {
                issueCount++; // Treat as one issue if multiple controls are affected
                listHtml += `<h3>11.2. Grouped Controls Missing Fieldset/Legend (1 or more issues)</h3><ul>`;
                listHtml += `<li class="WARNING">WARNING: Found multiple radio/checkbox inputs, but ${controlsOutsideFieldset.length} are not inside a <code>&lt;fieldset&gt;</code>/<code>&lt;legend&gt;</code> block. This is needed to group related choices for screen readers.</li>`;
                controlsOutsideFieldset.forEach(control => {
                    listHtml += `<ul><li>Source Code: <code>${escapeHTML(getOpeningTag(control))}</code></li></ul>`;
                });
                listHtml += '</ul>';
            }


            // --- 11.3 Required Attribute Mismatch Check ---
            const requiredElements = Array.from(doc.querySelectorAll('[required]'));
            
            const requiredMissingAria = requiredElements.filter(el => 
                el.getAttribute('aria-required') !== 'true'
            );

            const customRequiredElements = Array.from(doc.querySelectorAll('[aria-required="true"]:not([required])'));
            
            const totalRequiredIssues = requiredMissingAria.length + customRequiredElements.length;
            issueCount += totalRequiredIssues;

            if (totalRequiredIssues > 0) {
                listHtml += `<h3>11.3. Required Field Indicators (${totalRequiredIssues} issues)</h3><ul>`;
                if (requiredMissingAria.length > 0) {
                    listHtml += `<li class="WARNING">WARNING: ${requiredMissingAria.length} elements use the native <code>required</code> attribute but are missing the corresponding ARIA attribute (<code>aria-required="true"</code>). Consider using both for maximum compatibility.`;
                }
                if (customRequiredElements.length > 0) {
                    listHtml += `<li class="WARNING">WARNING: ${customRequiredElements.length} elements use <code>aria-required="true"</code> but are missing the native <code>required</code> attribute. Consider adding the native attribute for browser support.`;
                }
                listHtml += '</ul>';
            }

            
            let html = `<h2>11. Forms and Input Accessibility (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else if (controlsFound) {
                html += '<p class="SUCCESS text-sm">All form controls found appear to have accessible names and correct grouping.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }

        // 12. Keyboard Focus Check
        function checkKeyboardFocus(doc, resultsDiv) {
            let issueCount = 0;
            let listHtml = '';
            
            // Check for negative tabindex on focusable elements
            const negativeTabIndex = Array.from(doc.querySelectorAll('[tabindex="-1"]:not([role])'));

            // Check for positive tabindex (bad practice)
            const positiveTabIndex = Array.from(doc.querySelectorAll('[tabindex]:not([tabindex="0"]):not([tabindex="-1"])'));

            // Focusable elements without a default outline (requires style checking which DOMParser can't do well, so stick to tabindex issues)
            
            issueCount += negativeTabIndex.length;
            issueCount += positiveTabIndex.length;


            if (negativeTabIndex.length > 0) {
                listHtml += `<h3>Negative tabindex="-1" on Non-role Elements (${negativeTabIndex.length} issues)</h3><ul>`;
                negativeTabIndex.forEach(el => {
                    listHtml += `<li class="WARNING">WARNING: Element has <code>tabindex="-1"</code> without an explicit ARIA role. This removes it from the natural tab order. Use only for managed focus. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(el))}</code></li>`;
                });
                listHtml += '</ul>';
            }

            if (positiveTabIndex.length > 0) {
                listHtml += `<h3>Positive tabindex (>0) Found (${positiveTabIndex.length} issues)</h3><ul>`;
                positiveTabIndex.forEach(el => {
                    listHtml += `<li class="ERROR">ERROR: Element has a positive <code>tabindex</code>. This forces an unnatural tab order, which is hard to maintain and highly confusing for screen reader users. Use <code>tabindex="0"</code> instead. Source Code (Opening Tag): <code>${escapeHTML(getOpeningTag(el))}</code></li>`;
                });
                listHtml += '</ul>';
            }
            
            let html = `<h2>12. Keyboard Focus (${issueCount} issues)</h2>`;
            if (issueCount > 0) {
                html += listHtml;
            } else {
                html += '<p class="SUCCESS text-sm">No positive or unnecessary negative <code>tabindex</code> attributes found.</p>';
            }

            resultsDiv.innerHTML += html;
            return issueCount;
        }


        /**
         * Function to download the audit results as a text file.
         */
        function downloadResults() {
            const resultsContent = document.getElementById('results').innerText;
            const htmlCode = document.getElementById('codeInput').value;

            let fileContent = "--- Accessibility Quick Check Audit Results ---\n\n";
            fileContent += "--- A11Y ISSUES ---\n";
            fileContent += resultsContent.trim() + "\n\n";
            
            fileContent += "--- FULL HTML SOURCE CODE ANALYZED ---\n";
            fileContent += htmlCode;

            const blob = new Blob([fileContent], { type: 'text/plain;charset=utf-8' });
            const today = new Date().toISOString().slice(0, 10);
            const fileName = `a11y_audit_report_${today}.txt`;

            // Create a link element and trigger the download
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            document.getElementById('live-announcer').textContent = `Audit results downloaded successfully as ${fileName}.`;
        }
    </script>
</body>
</html>
